# 重构C程序
### 难点
许多有关重构和宏系统的工作都发生在C预处理器的上下文中，这使得传统的重构任务更加复杂，因为cpp工作在词汇层面而不是语法层面，并且可以扩展到代码片段。虽然用C或C++编写的代码比其他语言的代码要多很多，但能完全支持预处理器指令的为C语言创造的重构工具却很少。特别是对于那些含有预处理器指令的C语言，复杂的重构方式有可能会导致错误的重构。

为此，重构C语言主要由两大挑战需要解决，一方面，由于预处理器指令可能违反重构的正确性，我们必须为已经有的重构定义前提条件和执行规则来保持代码的行为；另一方面，自动执行的重构需要专门的分析工具来表示和操作的预处理指令。
### 宏的重构
#### 宏定义
一个简单的宏定义的形式如下所示：
```
#define name replacement_text
```
它要求对于简单的宏替换有随后出现的记号name将被replacement_text取代，这个替换文本是任意的，name中也可以包括参数。因为宏经常被使用到，故宏的定义不会经常变化，一些重构可能应用于宏定义，包括宏重命名、宏参数重命名、宏参数添加或删除等。对宏定义的重构的前提条件和执行规则基本类似于函数定义，前提条件包括检查新名称与范围中另一个程序元素的名称不冲突。执行过程包括在其作用域中重命名参数，但不修改任何其他名称相同但用途不同的程序元素。
```
#define M1(x, st) x = st.x
```
在上面的代码中，如果需要重命名的变量为x，则st.x中的x不应该被重命名。关于更多的复杂宏定义不再详述。
#### 宏调用
相对预处理器指令，当重构应用C代码时，如果宏的内容有指向全局程序元素，宏定义就可能会改变。因此，当重构C代码时，正常范围必须扩展到在该范围内调用的所有宏的主体范围。此外，研究表明，在如下三种情况下重构的正确性可能无法保证：
1. 如果定义了宏，但在重构的范围内从未调用过宏；
2. 如果宏指的是具有不同声明的变量，则从变量的不同上下文调用宏；
3. 如果宏定义使用连接运算符

对于第一种情况，示例代码如下：
```
#define QUEUE(q, ch) \
if (nelems < 10) \
{ (q)->nelems = ch; \
nelems++; \
}
```
为保证正确性，必须为 重命名重构方式增加一个前提条件，来检查被重命名的元素在宏内是否有被调用，如果有调用的话，保守起见，重构工作不应该进行。对于后两种情况也需要增加相应的前提条件或执行规则来保证执行的正确性，这里不再详述。
### 重构条件指令
C语言中经常会出现如下的条件编译指令：
```
#ifndef _BUFFER
#define _BUFFER
int nelems;
cqueue * q;
#else
unsigned short nelems;
#endif
```
这里并没有能够正确处理含有条件编译指令的重构方案，但是为了重构正确，我们应该要保证重构规则应适用于所有的选择条件。这里提出一些对于条件指令重构的规则：
1. 消除分支
2. 在条件分支内完成语句
3. 移动通用代码到条件指令外

###增强程序分析过程与程序表示
前面的部分提出了可能出现的宏和条件指令的的问题，必须在保证正确性的前提下进行重构。而对于诸如新的定义的范围，新的前提条件和执行规则，有多个类型相同的程序元素和新的重构的可能性之类的考虑，我们需要C工具有着特殊的程序分析功能和程序表示。

程序抽象语法树已经包含了我们分析所需要的的许多功能，在某些情况下，对于更复杂的程序，我们可能会使用到程序依赖图(program dependency graphs,PDGs),但需要更长的时间来构建，因此我们尽量去使用AST来进行我们的重构工作，我们相信AST包含了足够的信息。为了增强程序的分析过程，我们对AST进行了加强，使之能够提供更多的信息，另一方面，为了增强程序表示，类似符号表的程序表示的其他组件必须允许对同一程序元素的替代定义。

#### 参考文献
Garrido, A., Johnson, R.: Challenges of refactoring C programs. In: IWPSE ’02.pp. 6–14 (2002)
