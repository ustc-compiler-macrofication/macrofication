## 相关工作

​	macrofication将宏系统(macro system)和代码重构(refactoring)两个领域的工作进行了结合。一方面，借鉴了宏系统中的语法拓展性，使得macrofication具有了附加的语法抽象能力；另一方面，在代码重构中，借鉴了自动重构工具的实现思想。

### 宏系统

​	在Lisp类语言中，宏已经被广泛使用、研究了多年。Scheme语言格外支持宏，开拓了声明性质定义的开发，并同时为项重写的宏（规则宏）和过程宏（样例宏）开创了卫生条件(hygience conditions)。另外，已经有了集成过程宏和模块系统。同时，Racket语言在Scheme宏系统的基础上，通过编译过程中的钩(hook)和健壮的模式规范，做出了进一步工作。

​	近来，Scheme语言的形式卫生(formalizing hygiene)相关的工作也逐步开展。而之前的相关工作局限在Scheme的一个不包括语法示例(syntax-case)的子集中。

​	但有一系列语言的宏，不是建立在S表达式基础上的，如 Fortress，Dylan，Nemerle ，C++ templates和Template Haskell。但他们为了保证能够被区别，不得不通过强制宏调用站点(call sites)做出了妥协。这种实现是并不完善的，意味着Haskell语言无法通过宏定义基于Haskell定义新的语言。而这在Scheme和Racket中是可行的。

​	一些系统，如SugarJ和OMeta提供了拓展语法，但是却需要程序员推导语法分析的细节。多级系统，比如mython和MeatML同样能用来创建宏系统，如MacroML另外一些系统如Stratego和Marco，使用自己本身的语言转换语法，将其与宿主语言隔离。

​	正如之前提到的，我们的工具是建立在sweet.js之上的。其允许了不包含S表达式的更高级别的宏表达。ExJS是另外一种为Javascript提供的宏系统但是其实现基于解析结构，而不是如同Lisp，Scheme和sweet.js一样直接在语法层次进行操作。因此ExJS不支持模式宏。

​	macrofication的目的是引入新的语法糖(syntactic sugar)。最近关于resugaring的工作期望能在执行过程中保存或恢复语法糖，以方便调试。对比macrofication，resugaring在具体语言的抽象语法树(AST)上进行，而非语法树树。

​	宏系统可以概括为系统重写系统，其在过去几十年已经被广泛研究。不得不提的是，通过调整先前的研究，实现属性的静态分析是可能的。

### 重构

​	重构是提高代码可读性和可维护性的非正式活动，可以追溯到编程的早期。现在大多数流行语言的开发环境，如Visual Studio，Eclipse，IntelliJ IDEA等，都提供了内置的自动重构工具。

​	早期正式的重构处理方法研究了自动的重构功能和命令式与对象式的编程，并确保原始行为的保留。从那时起，为了将自动重构功能集成到集成开发环境中，做了大量的工作。其可以发现需要重构的代码，如重复代码，并将其自动转换，同时保留原始程序行为。大大改进了代码重构的体验。

​	此外，为了在Erlang，Netbeans，Ekeko/X实现重构，通用重构工具的前期工作包括了脚本语言和模板语言两部分。然而，这些重构语言在一个已解析的抽象语法树上运行，而宏描述的是在未扩展的符号树上进行的转换。

​	许多有关重构和宏系统的工作都发生在C预处理器(cpp)的上下文中，这使得传统的重构任务更加复杂，因为cpp工作在词汇层面而不是语法层面，并且可以扩展到代码片段。Garrido通过定义一个预处理器依赖图，解决了重构相关的许多问题。

​	Kumar等提出了一种将老c++代码库中的宏转换为c++ 11中新语言特性的宏去除(demacrofying)工具。从某种意义上说，它们做着macrofaction相反的工作：在相同的地方，demacrofying消除不必要的宏以获得清晰的代码库，而我们的重构宏将宏调用添加到代码库中，以达到类似的效果。

### 模式匹配

​	宏系统中的模式匹配是一种广泛的匹配算法的一部分。特别地，在这种扩展模式匹配算法中，重复变量的处理，在概念上，是一种一阶的句法统一。种种句法统一在逻辑编程语言的文法环境中是众所周知的。
