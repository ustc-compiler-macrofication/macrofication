# Macrofaction
重构的目标是在不改变其行为的情况下改进代码。 类似地，宏经常被用来为等效的扩展代码引入更简洁的符号。 宏的上下文中的自动重构工具因此可以自动地找到可以被对应且更简单的宏调用所代替的代码段。 

本节描述了一个基于模式模板宏的宏重构算法，本质上反过来应用它们，即使用宏的模板进行匹配代码，并插入宏名称和宏调用模式，并对变量进行正确的替换。 但macro和Macrofaction并不是完全对称的，由于不确定性，宏规则的重叠和重复变量在这里被处理。

## Basic reverse matcing
 宏扩展使用确定性的从左到右的递归来处理语法，直到所有的宏被扩展。 这个过程利用了宏调用始终以宏名开始的事实，所以如果语法序列的当前头与宏不对应，那么该tokens将不会成为任何其他后续扩展的一部分。 但是，在macrofication过程中，替换可能会导致重构的代码成为更大模式的一部分，也包括以前的tokens，如以下示例所示：
```
macro inc {
	rule { $x } = > { $x + 1 }
}
macro inc2 {
	rule { $x } = > { 1 + inc $x }
}
	macrofy Σ (1 + 2 + 1) → 1 + inc 2
	macrofy Σ (1 + inc 2) → inc2 2
```
扩展和macrofication之间的另一个不对称是由不同的语法可能扩展到相同的结果语法的事实引起的。 因此，虽然扩展过程总是为给定的语法产生单一的确定性结果，但是macrofication过程产生了重构程序的多个可能的候选，这些程序全部扩展到相同的结果并且行为相同。 在下面的例子中，两个不同的macrofication扩展到相同的程序。
```
macro inc {
	rule { $x } = > { $x + 1 }
}
```

由于这些原因，macrofication返回一组程序，而不是一个单一的结果。 如果h是语法的头部并且s是尾部，则结果是三个集合的结合：
1. 不涉及h的所有宏指令，
2. 如果h是分隔符{s 0}中的语法，那么也可以使用s 0和
3. 用由宏名称n和替换模式p组成的宏调用替换匹配的模板t而产生的程序。
值得注意的是，算法不会在宏的tokens tree上进行递归，因此每个返回的结果都是一个具有一步macrofication的tokens tree。 我们基于这种算法的开发环境使得程序员能够根据设计决策在这些候选中选择最好的重构程序，然后重复这个过程。

## Repeated variables
第二部分描述的模式匹配作为macrofaction算法的一部分，通过简单地将匹配的标记树添加到环境Θ来处理模式变量。这对应于大多数宏系统中常见的模式匹配行为。
但是，模式并不强制变量是唯一的，所以x·x是一个有效的模式。包括Racket ，Rust 和JavaScript在内的大多数现有的宏系统都不能正确处理重复的模式变量。
模式语言的这种限制通常是无关紧要的，因为宏模式被特别选择来以简明的方式绑定模式变量,他没有不必要的重复。然而，当模式变量在宏的模板中出现一次以上的时候，这种处理就很有意义。例如，下面所示的两次宏在模式（$ f $ x）中绑定$ f和$ x，然后在模板（$ f（$ f（$ x）））中多次使用$ f。
```
macro twice {
	rule { $f $x } = > { $f ( $f ( $x )) }
}
inc ( inc ( a ))
```
第3节中描述的macrofication算法使用模板进行模式匹配，以下示例说明了模式x x中重复变量的所需模式匹配。
```
match (x x, a a, ∅) → [x → a]
match (x x, a b, ∅) → no match
match (x x, {a b} {a b}, ∅) → [x → {a b}]
```
为了支持重复的变量，可以用algorithm扩展匹配函数。如果变量x之前没有被赋值，它将被绑定到序列中相应的token树h上。另一方面，如果变量已经是模式环境Θ的一部分，则语法h必须与先前绑定的语法相同。
```
match (x · p, h · s, Θ) = match (p, s, Θ[x → h])	(x 不属于 dom(Θ))
match (x · p, h · s, Θ) = match (p, s, Θ)			(Θ(x) = h)
```
虽然这个扩展的匹配算法能正确地处理简单模式和模板中的重复变量，但是后面给了一个更复杂的算法，它也支持任意嵌套的模式重复。与匹配模式中的重复变量相反，模板中的重复变量对于转录过程是不重要的。变量可以在模板中使用零次或多次，而不影响转录过程的其他部分。