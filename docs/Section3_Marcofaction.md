# Macrofaction
重构的目标是在不改变其行为的情况下改进代码。 类似地，宏经常被用来为等效的扩展代码引入更简洁的符号。 宏的上下文中的自动重构工具因此可以自动地找到可以被对应且更简单的宏调用所代替的代码段。 

本节描述了一个基于模式模板宏的宏重构算法，本质上反过来应用它们，即使用宏的模板进行匹配代码，并插入宏名称和宏调用模式，并对变量进行正确的替换。 但macro和Macrofaction并不是完全对称的，由于不确定性，宏规则的重叠和重复变量在这里被处理。

## Basic reverse matcing
 宏扩展使用确定性的从左到右的递归来处理语法，直到所有的宏被扩展。 这个过程利用了宏调用始终以宏名开始的事实，所以如果语法序列的当前头与宏不对应，那么该tokens将不会成为任何其他后续扩展的一部分。 但是，在macrofication过程中，替换可能会导致重构的代码成为更大模式的一部分，也包括以前的tokens，如以下示例所示：
```
macro inc {
	rule { $x } = > { $x + 1 }
}
macro inc2 {
	rule { $x } = > { 1 + inc $x }
}
	macrofy Σ (1 + 2 + 1) → 1 + inc 2
	macrofy Σ (1 + inc 2) → inc2 2
```
扩展和macrofication之间的另一个不对称是由不同的语法可能扩展到相同的结果语法的事实引起的。 因此，虽然扩展过程总是为给定的语法产生单一的确定性结果，但是macrofication过程产生了重构程序的多个可能的候选，这些程序全部扩展到相同的结果并且行为相同。 在下面的例子中，两个不同的macrofication扩展到相同的程序。
```
macro inc {
	rule { $x } = > { $x + 1 }
}
```

由于这些原因，macrofication返回一组程序，而不是一个单一的结果。 如果h是语法的头部并且s是尾部，则结果是三个集合的结合：
1. 不涉及h的所有宏指令，
2. 如果h是分隔符{s 0}中的语法，那么也可以使用s 0和
3. 用由宏名称n和替换模式p组成的宏调用替换匹配的模板t而产生的程序。
值得注意的是，算法不会在宏的tokens tree上进行递归，因此每个返回的结果都是一个具有一步macrofication的tokens tree。 我们基于这种算法的开发环境使得程序员能够根据设计决策在这些候选中选择最好的重构程序，然后重复这个过程。