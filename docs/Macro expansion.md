# Macro expansion
在这里我们将简要介绍宏是如何工作的，这是为了下一步介绍macrofication如何工作做铺垫；

在这里我们的宏的定义大多独立于目标语言，现在我们假设代码已经被展开成一系列的tokens，这些tokens已经被进一步处理为一系列的tokens tree。

如下，我们设h为一个tokens tree，那么他可以是单个tokens k，也可以是被包围在分隔符{s}中的序列:
```
h :: = k | {s}
s ::= k · s | {s} · s | 空
```
在这里的程序被转换成一个tokens tree的序列；

用于划分tokens tree的字符与程序自己的算法无关(这是显而易见的)，所以一个复杂的阅读器/词法分析器可以支持许多不同的分隔符，例如， {}，[]或（）；所以这种方法支持Lisp-like和JavaScript-like两种语言。

下面是一个例子：
JavaScript语句“arr [i + 1];”可以表示为以下的tokens tree序列，其中方括号“[”和“]”在分隔符匹配之后变成简单的tokens k。
```

```

在这里，我们将一个模式或模板定义为一系列包含在分隔符中的标记，变量和模式模板序列。

在这里，我们将将宏环境Σ中的所有宏表示为（名称，模式，模板）元组的有序序列。
` `

模式变量x要么未绑定，要么绑定到tokens tree h。我们使用Θ来表示变量绑定的环境。
` `

在最简单的情况下，所有宏在扩展之前是已知的，并且具有全局范围。给定宏的固定列表Σ，那么将宏展开之后，原有的tokens tree（不包括宏定义）将转换为所有宏都已经被匹配和扩展的新的tokens tree序列：

对于每个tokens k，我们将查找其宏环境Σ为一个名为k的宏并且用模式p匹配标记。 如果不存在这样的宏，我们将不使用宏语法来代替tokens，否则使用第一个找到的相应的匹配的宏来匹配语法，产生新的变量绑定，然后用它来转录模板t。同时得到的tokens序列也可能包含其他宏调用，所以有可能会有递归的调用，直到所有的宏都被扩展。这个过程不能保证终止，因为rule macros是Turing-complete的。
例如，下面的宏将导致无限扩展：
```
macro omega { rule {} = > { omega } }
```
















