# Repetitions in patterns

把前面提到的重构算法扩展到一种更具有表达力的模式或模板语言上并没有影响到重构的基本思想和结果的正确性。然而，为了匹配任意次重复的模式，我们需要一个更加复杂的模式匹配算法。模式重复是指一个模式支持匹配无限制次数的某个片段的序列，这种模式在很多宏中都被用到，例如：
```
p, t ::= k · p | {p} · p | x i · p | (p) ... · p | null
```
如果没有模式重复，模式变量仅仅只在一棵记号树h上被赋值，然而，如果存在模式重复，它可能在多棵数上出现，并且每次内部的模式都会被重复。模式重复是可以嵌套的，这也是一直以来匹配算法要解决的目标，每个模式变量x具有一个层次i，这是由模式重复的嵌套决定的。在最简单的情况下，变量的层次对应于模式重复的嵌套，例如x在模式k·x·k中具有层次0，在k·(x·k)中具有层次1等。在一次成功匹配之后，具有层次1的变量x将对应一个序列的h记号树，具有层次2的变量x将对应一个序列的序列的h记号树，以此类推。
在成功地匹配到一个完整的模式后，最后的模式环境总是把变量x对应到具有相同层次的一组记号树上。由于在匹配内层模式时，整个过程是递归的，故在匹配过程中，具有层次i的变量x可能对应于一组低层次，但是具有层次j的变量却永远不可能对应于高层次。为了描述目前的嵌套层次，匹配算法中需要增加一个参数j，j初始化为0，即最顶层。对于任何嵌套层次j，中间模式环境总是把(子)模式p中的自由的模式变量映射到层次i-j。

## 转录重复的模板

在给定环境的情况下，转录一个模板(t)...·t'是指展开t中所有组变量然后从t'继续。如果t中只有一组变量x，并且具有长度n，那么模板t将会被转录n次，并且每次会给具有层次i的变量x不同的赋值，最后的结果便是这些重复的连接。如果出现超过一组变量，所有的变量同时展开，然后在第一个重复部分对每个不同层次的x赋值，在第二个重复部分再对每个不同层次的x赋一次值，以此类推。内部模板一直在重复地转录直到变量为空，这表明目前所有组的重复变量需要有着相同的长度。正如之前提到了那样，在转录过程中，一个模板中重复变量是无关紧要的，对于转录模板和模式重复也是如此。

## 匹配重复的模式

匹配一个模板(p)...·p'正好是转录模板(t)...·t'的逆过程。如果没有重复变量，内部模式p将会贪心地匹配尽可能多次数的重复直到剩下的语法s'和新的模式环境将会被用来匹配剩下的模式p'。与转录算法中减少变量不同，每个重复部分都会通过向变量中添加匹配的语法来修建所有组变量。
然而，贪心匹配并不能支持类似(a)...a的模式，因为前面的重复会消耗掉所有的a，以致于结尾没有a可以匹配。可能的解决方案为通过前看来避免或者通过回溯来从错误中恢复，然而，这些方法都太低效了，在实际应用中也并不常见。

## 匹配重复变量
正如前面提到了那样，重构中的模式匹配需要支持模式和模板中重复变量。如果一个模式变量在相同的层次中重复，那么这组变量匹配的次数也是相同的。如果一个模式变量一次被用在重复部分里面，一次被用在重复部分里面，那这个变量在内部出现时都要再重复一遍外面循环的语法。这就意味着当匹配重复模式时，变量赋值将会是常数，并且使用的是更低层次。比如，模式x(xy)...使用了两个变量x和y，y只在重复部分内部出现一次，匹配成功后会使记号树的一部分记号每次重复获得一次赋值。而x则属于第二种情况，所以x需要匹配额外的语法。外部的x最终会使单个记号得到赋值，内部的x也需要按照这种语法而不是建立一组值。
这就导致了匹配过程变得更加复杂，因为变量的层次可能会与嵌套层次不同。如果一个变量在模板中的层次比在模式中的层次高，它会被匹配并使用一个更低层次的变量，例如为了能与模式匹配而被当作常量。这个对重构过程非常重要，因为模板可能用到一个重复部分内部的变量并且这个变量可能会是常数。为了支持模式中的重复变量，扩展匹配算法是十分必要的。从概念上来说，当我们在匹配过程中第一次遇到具有层次i变量x，这个元素就被贪心地匹配到，然后递归地构造出对应i的组h。然而，一旦一个模式变量被赋值，所有对那个变量的子序列的使用都将会让模式重复按照前面的转录算法展开。
