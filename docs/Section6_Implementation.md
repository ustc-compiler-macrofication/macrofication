## Implementation
在这里，我们的实现是sweet.js的一部分，它是支持模式宏模型的JavaScript卫生宏系统。[源代码](https://github.com/sweet-js/sweet-core) （see src/reverse.js, src/patterns.js）以及[实时在线演示](http://sweetjs.org/browser/editor.html) 都是公开的。
sweet.js现在使用扩展模式匹配算法进行macrofication和regular的宏扩展。我们的大部分实现都是我们所描述的算法的简单应用。但是，有一些JavaScript的具体细节，特别是，由于JavaScript语法的复杂性，sweet.js提供了模式变量匹配特定模式类以及匹配单个或重复标记的功能。模式类还允许宏匹配多个tokens，如下：
```
macro m {
	rule {
		( $bind :( $id : ident = $val : expr ) ( ,)...)
	} => {
		$ ( var $bind ;) ...
	}
}
m 	a = 2 + 1 , 	// --> var a = 2 + 1;
	b = 3		//	var b = 3;
```
考虑到代码片段arr [i + 1]，模式变量$x仅匹配单个标记arr，而模式$x：expr匹配整个表达式arr [i + 1]。 模式类注释只出现在模式中，而不是模板，所以为了支持模式类的宏观化，我们把模式类注释从模式移动到模板中相应的变量，然后将模板与代码进行匹配。
对于宏环境的处理。一般来说的宏定义与程序明确分离，并且在全局范围内。相比之下，sweet.js宏定义在代码中定义，除非在范围内，否则不能使用。重构算法的当前实现仅支持全局宏，但可以进行修改，使得宏环境Σ尊重宏定义的范围。
sweet.js重构工具可以在命令行中使用，也可以在基于web的sweet.js编辑器中使用。正如在第3节中所讨论的那样，并不是所有的重构选项都实际上改进了代码，他们可能是相互排斥的。为了解决这个问题，开发环境通过突出显示代码并按需打开重构代码的弹出式覆盖图来显示所有选项。这种整合提供了关于重构机会的不显眼的视觉反馈，但是如果存在大量的宏化候选，则显示这些的其他方式可能是优选的。
