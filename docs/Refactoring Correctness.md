##Refactoring Correctness
虽然之前提到的模式匹配算法可以确保正确处理重复变量的问题，但是算法本身却可能改变了代码的行为，我们还需要继续考宏扩展的顺序和变量在卫生宏系统中的作用域。
####宏扩展冲突
由于我们可能同时会找到多个规则匹配，这时宏扩展算法的策略是取最先匹配到的一个规则进行匹配，这就可能会因宏扩展规的顺序不同而导致结果不同，例如下面这个规则：
```
macro inc { 
	rule { 1 } => { 3 } 
	rule { $x } => { $x + 1 } 
}
```
对于程序1+1，我们想利用宏的第二条规则将其改为inc 1，然而由于宏的第一条规则优先级更高，我们得到了结果3。事实上甚至在只有一条规则的情况下，宏扩展的顺序也会影响到结果，例如下面的规则：
```
macro inc {
rule { $x } => { $x + 1 } 
}
```
对于程序2 + 1 + 1，模式匹配算法会首先将其变为inc 2 + 1，然后继续得到inc inc 2，这就可能会展开成错误结果，先展成inc + 1 2，继续展开得到+ + 1 1 2，改变了程序的行为。为了防止这种错误的二次匹配，一种改进的算法策略是回看之前的语法，考虑所有的有可能影响代码行为的宏展开。然而，由于我们是在无标记的记号树上执行算法的，我们无法给出调用深度的一个上界。

####卫生

卫生宏系统的基本前提是保持初值相等，这也就要求一个宏中变量的作用域应当是与宏扩展文本中的作用域是分离的。一直以来，反向宏扩展算法并没有处理卫生、变量的作用域或者目标语言具体的语法语义。然而，实际应用中大多数的宏系统遵守卫生并相应地重命名变量，例如下面这个宏：
```
macro decprint {
	rule { $x; } => { var a = $x - 1; print(a); } 
}
```
对于如下程序：
```
var a = 23;
decprint a;
print(a);
```
宏替换时会重命名一个a2，改变后的程序如下：
```
var a1 = 23;
var a2 = a1 - 1;
print(a2); // 22 
print(a1); // 23
```
在大多数情况下，卫生是与macrofication一致的，在原先代码中不同名字的变量在扩展代码中也有着不同的名字。只要扩展出的代码保持初值相等，重命名这件事对于程序行为来说就是不重要的。然而，如果原始代码有意使用宏中相应的变量定义，例如下面这段代码：
```
var a = 23;
var a = a - 1;
print(a);
print(a);
```
经过反向宏扩展后变为：
```
var a = 23;
decprint a;
print(a);
```
进行宏替换后，程序如下：
```
var a1 = 23;
var a2 = a1 - 1;
print(a2); // 22 
print(a1); // 23
```
我们可以看到结果改变了程序的行为。

####避免错误的重构代码
前两部分展示了重构时我们需要避免的一些重构代码错误。由于重构的正确性很大程度上取决于上下文语法，比如任意的长前缀等，找到解决问题的高效算法是十分困难的。纵使我们可以用复杂的动态检查来解决这个问题，但解决变量作用域上重命名问题仍然很困难。与简单的扩展和macrofication过程相比，卫生要求关于变量作用域的信息，这部分信息通常在抽象语法树上定义，而我们却是在无符号的记号树上执行算法的。
我们通过在重构算法之后进行一个简单的检查解决了这些问题。它检查出那些在代码用宏展开后在语法上与原文初值不等的项目，就是这样一个简单的检查成功地解决了前面关于正确性的问题，并且还没有增加算法的复杂度。然而，强制语法上的等值可能也会拒绝掉其他一些不改变程序行为的重构机会，例如增加或缺失可选分号。在未来，将这一标准扩展到语义上的等值将会提升算法的健壮性，但是语义等值本身在一般情况下就是不确定的。